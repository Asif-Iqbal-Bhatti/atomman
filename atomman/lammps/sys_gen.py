# Standard Python libraries
from __future__ import (absolute_import, print_function,
                        division, unicode_literals)

# http://www.numpy.org/
import numpy as np

# atomman imports
import atommantest.Atoms
import atommantest.System
from ..compatibility import range

def sys_gen(units = 'metal',
            atom_style = 'atomic',
            pbc = (True, True, True),
            ucell = atommantest.System(atoms=atommantest.Atoms(atype=1, pos=[[0.0, 0.0, 0.0],
                                                     [0.5, 0.5, 0.0],
                                                     [0.0, 0.5, 0.5],
                                                     [0.5, 0.0, 0.5]])),
            axes = [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
            shift = [0.1, 0.1, 0.1],
            size = [[-3,3], [-3,3], [-3,3]]):
    """
    Generates the LAMMPS input command lines associated with having LAMMPS
    create a system.
    
    Parameters
    ----------
    units : str
        LAMMPS units option to use. Default value is 'metal'.
    atom_style :str 
        LAMMPS atom_style option to use. Default value is 'atomic'.
    pbc : list of bool
        3 boolean values indicating which directions are periodic. Default
        value is (True, True, True).
    ucell : atomman.System
        A small system (e.g. crystallographic unit cell) to use as the basis.
        Default is a standard fcc unit cell with a = b = c = 1.
    axes : np.ndarray
        (3,3) array of crystallographic axes to rotate the ucell by.
        Default value is [[1,0,0],[0,1,0],[0,0,1]] (i.e. no rotation).
    shift : np.ndarray or list of float
        A box-scaled vector to rigidly shift all atoms by. Default value is
        [0.1, 0.1, 0.1].
    size : np.ndarray
        (3, 2) array of system multipliers to expand the system by.  Default
        value is [[-3,3], [-3,3], [-3,3]], i.e. 6x6x6 supercell of ucell where
        Cartesian (0,0,0) is in the center.
        
    Returns
    -------
    str
        The LAMMPS input command lines telling LAMMPS how to generate a system.
    """
    # Convert inputs to arrays if needed
    size = np.asarray(size, dtype='int64')
    shift = np.asarray(shift)
    axes = np.asarray(axes)
    
    # Extract ucell values
    vects = ucell.box.vects
    natypes = ucell.natypes
    natoms = ucell.natoms
    spos = ucell.atoms_prop(key='pos', scale=True)
    atype = ucell.atoms.atype
    
    # Generate boundary string
    boundary = ''
    for i in range(3):
        if pbc[i]:
            boundary += 'p '
        else:
            boundary += 'm '
    
    # Generate position and type basis strings
    pos_basis = ''
    type_basis = ''
    for i in range(natoms):
        pos_basis += '        basis %f %f %f' % tuple(spos[i])
        if i < natoms - 1:
            pos_basis += ' &\n'
        
        if atype[i] > 1:
            type_basis += ' &\n             basis %i %i'%(i+1, atype[i])
    
    # Test if box is orthorhombic
    if vects[1][0] == 0.0 and vects[2][0] == 0.0 and vects[2][1] == 0.0:
        region_box = 'region box block %i %i %i %i %i %i' % (size[0,0], size[0,1],
                                                             size[1,0], size[1,1],
                                                             size[2,0], size[2,1])
        ortho = True
    else:
        assert np.allclose(axes[0], [1,0,0]) and np.allclose(axes[1], [0,1,0]) and np.allclose(axes[2], [0,0,1]), 'Rotation of non-orthogonal box not suppported by this function'
        ortho = False
        size_xy = vects[1][0] * (size[0,1] - size[0,0]) / ucell.box.a
        size_xz = vects[2][0] * (size[0,1] - size[0,0]) / ucell.box.a
        size_yz = vects[2][1] * (size[1,1] - size[1,0]) / ucell.box.b
        region_box = 'region box prism %i %i %i %i %i %i %f %f %f' % (size[0,0], size[0,1], size[1,0],
                                                                      size[1,1], size[2,0], size[2,1],
                                                                      size_xy,   size_xz,   size_yz)
    
    # Adjust crystal spacing for systems to be (nearly) perfectly periodic across boundaries
    spacing = np.zeros(3)
    for i in range(3):
        spacing[i] = vects[i][i] * ((axes[i,0]**2+axes[i,1]**2+axes[i,2]**2)**0.5)
    
    newline = '\n'
    script = newline.join(['#Atomic system info generated by AtomMan package',
                           '',
                           'units ' + units,
                           'atom_style ' + atom_style,
                           ''
                           'boundary ' + boundary,
                           '',
                           'lattice custom 1.0 &',
                           '        a1 %.12f %.12f %.12f &'      % (vects[0][0], vects[0][1], vects[0][2]),
                           '        a2 %.12f %.12f %.12f &'      % (vects[1][0], vects[1][1], vects[1][2]),
                           '        a3 %.12f %.12f %.12f &'      % (vects[2][0], vects[2][1], vects[2][2]),
                           '        origin %f %f %f &'           % (shift[0], shift[1], shift[2]),
                           '        spacing %.12f %.12f %.12f &' % (spacing[0], spacing[1], spacing[2]),
                           '        orient x %i %i %i &'         % (axes[0,0], axes[0,1], axes[0,2]),
                           '        orient y %i %i %i &'         % (axes[1,0], axes[1,1], axes[1,2]),
                           '        orient z %i %i %i &'         % (axes[2,0], axes[2,1], axes[2,2]),
                           pos_basis,
                           '',
                           region_box,
                           'create_box %i box' %(natypes),
                           'create_atoms 1 box' + type_basis])
    return script